Q :
    일봉전략과 분봉전략을 이용해서 백테스팅 프로그램을 만들었다.
    trading 폴더, strategies 폴더, manager 폴더, tests 폴더 참고.
    백테스팅 엔진 Backtest & Broker (백테스팅용 브로커) 관계처럼,
    자동매매 Trading & Brokerage (자동매매용 브로커) 를 만들어서
    백테스팅에 사용한 일봉 전략과 분봉전략을 수정없이 자동매매를 할 수 있도록
    Trading 와 Brokerage 를 개발하는 것이 목표다.

    사용자 요구사항은 다음과 같다.
    1. Trading 의 생성자는 Backtest와 동일하게 한다.
    2. Brokerage 의 생성자도 Broker와 동일하게 한다.
    4. 전략을 공유하려면 백테스트용 Broker와 자동매매용 Brokerage 는 전략파일에서 사용하는 메서드를 동일하게 만들어야 하므로
       미리 trading/abtract_broker.py 추상클래스를 만들어 놨고, 현재 Broker 는 이를 상속해서 구현되어 있다.
    5. 자동매매시 언제든지 매매대상 종목, 전략을 교체할 수 있다.
    6. 백테스트는 전일 일봉 종가로 일봉전략을 적용해서 매매일 분봉전략을 적용해서 매매를 한다.
       그러나 자동매매는 장중에 종목의 당일 현재가=종가가 계속 변하므로, 
       1분 주기로 관심종목의 일봉전략을 다시 실행(백테스트과 같은 기능)해서 매매신호를 발생하게 하는 게 맞는 처리일 것 같다. 
    7. 분봉전략은 자동매매에서는 실제시간으로 실제 매매를 하는 것이, 백테스트에서 시간을 바꿔가며 백테스트 매매를 하는 것과 차이점이다.
       그래서, 자동매매에서는 Brokerage를 사용해서 증권사 api 와 연동하는 기능을 추가하여 실제매매가 되도록 한다.
    8. 자동매매는 시스템을 수시로 끄고 켜기 때문에, 이전 자동매매 상태가 연결될 수 있도록 DB를 사용한다.
       그리고 매매와 관련된 데이터는, 증권사 api 로 가져온 데이터와 DB 데이터, 시스템 상의 데이터의 싱크가 맞도록 보장해야 한다.

    백테스트와 앞으로 개발하려는 자동매매는 다음 차이가 있다.
    1. 백테스트는 시작과 종료가 한번에 이루어 진다.
    그러나, 자동매매는 오늘의 매매가 끝나면, 전략에서 만들어진 매매신호와 매매결과를 백테스트 처럼 메모리 상에 보관하지 못하므로,
    DB에 저장해서, 다음날로 매매신호와 매매결과를 Trading 와 Brokerage 가 DB 를 통해서 교환할 수 있도록 하는 구조를 만들어야 한다.
    2. Trading, Brokerage 는 실제 매매를 하기 위해 증권사 api 를 이용해서 필요한 데이터를 요청, 수신해야 하고,
    DB에 저장, DB로 부터 불러들이는 작업도 해야 하므로, 증권사 api 와 DB를 서로 연결하는 기능을 해야 한다.
    그래서 trading_manager.py 에 필요한 메소드를 만들어 자동매매에서 호출할 수 있도록 한다.
    3. /manager/sql/create_stock_table 스크립트의 종목, 주가 관련 테이블은 그대로 사용한다,
    자동매매에서 필요한 테이블도 별도 생성해야 한다. (create_trading_tables 스크립트 생성 필요)
    4. /api/creon_api 에는 자동매매를 지원하는 api 호출 함수를 넣어 뒀다.
    5. 백테스트 결과를 기록하는 /manager/sql/create_backtest_talbes.sql 스크립트가 있는데
       자동매매도 매매결과를 집계하는 비슷한 구조의 파일이 필요할 것이다. 
       자동매매는 백테스팅과 다른 테이블을 사용한다.
    7. 자동매매에서는 증권사의 내 계좌 내의 현금잔고, 보유종목 정보, 매매 내역, 미체결 내역들과 관련된 DB 데이터 싱크를 맞춰야 한다.
    8. 주문후 주문결과가 바로(1초 이내) 체결이 되지 않으면, 실시간 미체결 내역 구독 서비스로 미체결의 변화를 추적, 반영해야 한다.    
    9. 이상 언급하지 않은 부분은 너의 지식을 바탕으로 수정 또는 보완해서 제안해 주기 바란다.
    
    현재 개발완료되어 파일로 첨부해 업로드한 백테스트 프로그램을 학습해라.

앞으로 개발되어야 자동매매 프로그램의 세부 개발 사항은 다음 처럼 정리될 수 있다.

이상의 요구사항을 만족하는 자동매매 Trading trading.py 와 Brokerge brokerage.py 를 만들어라.

A :
    자동매매 시스템 개발 목표에 대한 분석 및 제안 드립니다. 기존 백테스팅 시스템의 구조와 전략을 최대한 재활용하면서 실시간 자동매매 환경의 특성을 반영하는 것이 핵심입니다.
    제안하는 자동매매 프로그램의 구조와 개발 방안은 다음과 같습니다.

    1. 주요 구성 요소 및 역할
    기존의 Backtest - Broker 관계처럼, 자동매매에서는 Trading - Brokerage 관계가 중심이 됩니다. 여기에 데이터 관리와 실제 증권사 API 연동을 위한 TradingManager가 추가됩니다.

    Trading.py (신규 개발):

    역할: 자동매매 시스템의 총괄 제어 센터입니다. 매일 장 시작 전 초기화부터 장 마감 후 정리까지의 전체 자동매매 사이클을 관리합니다. 백테스터와 유사하게 전략 인스턴스를 관리하지만, 모든 상태를 DB에 영구적으로 저장하고 로드하는 방식으로 동작합니다.
    주요 기능:
    - 일일 라이프사이클 관리: 장 시작 전 데이터 업데이트, 일봉/분봉 전략 실행, 장 중 실시간 데이터 처리, 장 마감 후 정산 및 보고서 생성 등을 총괄합니다.
    - 상태 동기화: Brokerage 및 TradingManager를 통해 계좌 잔고, 보유 종목, 실시간 체결 내역 등을 주기적으로 동기화합니다.
    - 신호 전달: 자동매매 Loop 내의 TradingStrategy에서 상속받은 각 매매기법에 따른 전략이 생성된 매매 신호를 signals 딕셔너리에 종목별 signal 을 저장하고, 모든 signals 를 TradingManager를 통해 DB에 저장합니다. 
      장 중 Brokage가 signals를  불러와 매매를 처리하도록 합니다.
      DB에 저장된 signal은 시스템이 재기동 할때 다시 signal 딕셔너리에 복원하도록 합니다.

    Brokerage.py (수정 및 구현): creon_api, db_manager, trading_manager 필요
    역할: trading/abstract_broker.py를 상속받아 Brokerage를 구현합니다. 
    Brokerage는 실제 증권사 API(creon_api.py)를 통해 주문을 실행하고, 실제 계좌 잔고 및 보유 종목 정보를 관리합니다. 백테스팅용 broker.py와 달리 실제 돈이 오고 가는 핵심 모듈입니다.
    반면 Backtest에서는 이를 상속받아 Broker 를 구현하여, 매매결과를 DB 에 저장하여 백테스팅 결과를 분석하늗데 사용하도록 합니다. 
    주요 구현 사항:
    execute_order(): 증권사 API(creon_api.py)를 이용하여 실제 주식 매수/매도 주문을 전송하는 로직을 구현합니다. 주문 직후 trading_log 테이블에 주문 정보를 기록합니다.
    get_position_size(), get_portfolio_value(): 증권사 API(creon_api.py)를 통해 현재 계좌의 실제 보유 수량과 포트폴리오 가치를 조회하는 기능을 구현합니다.
    set_stop_loss_params(), check_and_execute_stop_loss(), check_and_execute_portfolio_stop_loss(): 백테스팅 브로커와 동일한 인터페이스를 유지하되, 
    손절매 발생 시 실제 시장가/지정가 매도 주문을 증권사 API(creon_api.py)를 통해 실행하도록 구현합니다.
    실시간 잔고/체결 동기화: 증권사 API(creon_api.py)를 통해 계좌 잔고 및 미체결/체결 내역을 주기적으로 조회하여 동기화 합니다.
    매매상태 변경시 저장 후 조회(trading_manager.py)하여 내부 상태와 DB를 업데이트하는 메커니즘이 필요합니다.
    동기화는 증권사 api 를 통해 현재 계좌의 실제 보유 수량과 포토폴리오 가치를 자동매매 프로그램의 signals와 positions를 동기화 시키는 작업으로 증권사 계좌의 정보를 가져와 동기화 합니다.
    
    trading_strategy.py (매매 전략 추상클래스 신규 개발):
    이를 구현한 각 매매 전략 클래스 : 예) 이평선 매매 전략 sma_strategy.py, 듀얼 모멘텀 전략 dualmomentun_strategy.py
    역할: 자동매매 Loop 내에서 매매전략에 따른 매매신호를 생성하여 Brokerage가 실제 매매 처리 할 수 있도록 합니다.
    주요기능:
    - 매매대상 종목 유니버스 관리 : 매매전략에 맞는 종목을 필터링하여 유니버스를 업데이트 하고, 
    - 유니버스 종목의 일봉과 분봉 가격 정보를 실시간으로 증권사 API(creon_api.py) 를 통해 갱신하며, DB daily_price, minute_price 에 저장합니다. 
    실시간 갱신과 저장기능은 trading_manager.cache_minute_price 에 구현되어 있습니다.
    - 매매신호 발생 : signals 딕셔너리에 signal 신호를 추가/업데이트 합니다. trading_manager 를 통해 daily_signals 테이블 에 저장합니다.
    - 모든 매매 전략에서 사용할 공통된 기능은 추상클래스 에 구현합니다.

    trading_manager.py (신규 개발): creon_api, db_manageer 필요
    역할: manager/data_manager.py와 유사하게 데이터베이스(db_manager.py)와 증권사 API(creon_api.py) 간의 모든 데이터 입출력을 담당합니다. 특히 자동매매에 필요한 실시간 데이터 및 상태 정보를 관리합니다.
    주요 기능:
    데이터 수집:
    실시간 데이터: 증권사 API(creon_api.py)를 통해 현재가, 호가, 분봉 데이터 등을 실시간으로 수신하는 기능을 제공합니다. (크레온 API의 실시간 통신 방식 활용)
    과거 데이터: daily_ohlcv, minute_ohlcv 테이블에서 과거 데이터를 조회하거나, 필요한 경우 증권사 API(creon_api.py)를 통해 조회하여 DB에 저장합니다.
    계좌 정보: 증권사 API(creon_api.py)를 통해 현재 보유 종목, 잔고, 미체결/체결 내역 등을 조회합니다.
    상태 정보 영속화:
    - 매매 신호 저장/로드: TradingStrategy에서 생성된 신호를 daily_signals 테이블에 저장하고, MinuteStrategy가 이를 로드할 수 있도록 합니다.
    - 거래 로그 저장: Brokerage에서 발생한 모든 주문 및 체결 내역을 trading_log 테이블에 저장합니다.
    - 포트폴리오 스냅샷 저장: 일별 포트폴리오 현황을 daily_portfolio 테이블에 저장합니다.
    - 현재 보유 종목 관리: current_positions 테이블에 현재 보유 중인 종목의 상세 정보(수량, 매입단가 등)를 실시간으로 업데이트합니다.
    - 현재 신호 관리 : daily_signals 테이블에 현재 신호 정보(신호종류)를 실시간으로 업데이트 합니다. 

    이상의 나의 요구사항을 만족하는 자동매매 프로그램을 개발하려면 어떻게 해야 할지,
    첨부한 파일을 분석하고, 현재 시장에서 유명한 자동매매 프로그램에 대한 지식을 활용해서,
    보완사항과 제안을 추가해서 개발 요구사항을 만들어라.
    
 
    create_trading_tables.sql (신규 개발):
    역할: 자동매매 시스템 운영에 필요한 새로운 데이터베이스 테이블 스키마를 정의합니다. 
    기존 create_stock_tables.sql은 주식 데이터(stock_info, daily_ohlcv, minute_ohlcv)를 위한 테이블로 백테스팅과 자동매매 모두에서 공유하여 사용할 수 있습니다.

    제안 테이블:
    daily_signals: 일봉 전략이 생성한 매수/매도 신호를 저장합니다. 
    SQL
    CREATE TABLE IF NOT EXISTS daily_signals (
        signal_date DATE NOT NULL COMMENT '신호 생성일',
        stock_code VARCHAR(10) NOT NULL COMMENT '종목 코드',
        strategy_name VARCHAR(50) NOT NULL COMMENT '전략명',
        signal_type VARCHAR(10) NOT NULL COMMENT '신호 유형 (BUY, SELL, HOLD)',
        target_price DECIMAL(15, 2) COMMENT '목표 가격 (매수/매도 시)',
        signal_score DECIMAL(10, 4) COMMENT '신호 점수 (선택적)',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- 시뮬레이션에 필요
        PRIMARY KEY (signal_date, stock_code, strategy_name)
    ) COMMENT='일봉 전략 매매 신호';

    trading_log: 실제 증권사에 전송된 주문 및 체결 상세 내역을 기록합니다.
    SQL
    CREATE TABLE IF NOT EXISTS trading_log (
        log_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '로그 ID',
        order_time DATETIME NOT NULL COMMENT '주문 시각', 
        stock_code VARCHAR(10) NOT NULL COMMENT '종목 코드',
        order_type VARCHAR(10) NOT NULL COMMENT '주문 유형 (BUY, SELL)',
        order_price DECIMAL(15, 2) COMMENT '주문 가격',
        order_quantity INT NOT NULL COMMENT '주문 수량',
        executed_price DECIMAL(15, 2) COMMENT '체결 가격',
        executed_quantity INT COMMENT '체결 수량',
        commission DECIMAL(15, 2) COMMENT '수수료',
        tax DECIMAL(15, 2) COMMENT '세금',
        net_amount DECIMAL(15, 2) COMMENT '실제 금액 (수수료, 세금 포함)',
        order_status VARCHAR(20) NOT NULL COMMENT '주문 상태 (PENDING, FILLED, PARTIAL_FILLED, CANCELED, REJECTED)', -- 백테스트에는 없는 필드
        creon_order_id VARCHAR(50) COMMENT '크레온 주문번호 (실제 주문 식별자)',
        message TEXT COMMENT '추가 메시지',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP -- 시뮬레이션에 필요
    ) COMMENT='실시간 자동매매 주문 및 체결 로그';

    daily_portfolio: 매일 장 마감 시점의 포트폴리오 현황을 기록합니다.
    SQL
    CREATE TABLE IF NOT EXISTS daily_portfolio (
        portfolio_date DATE PRIMARY KEY COMMENT '포트폴리오 날짜',
        cash DECIMAL(20, 2) NOT NULL COMMENT '현금 잔고',
        total_asset_value DECIMAL(20, 2) NOT NULL COMMENT '총 자산 가치 (현금 + 주식 평가액)',
        total_stock_value DECIMAL(20, 2) NOT NULL COMMENT '총 주식 평가액',
        profit_loss_rate DECIMAL(10, 4) COMMENT '일일 수익률',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    ) COMMENT='일별 포트폴리오';

    current_positions (선택적): 현재 보유 종목의 포지션 정보를 명시적으로 관리하는 테이블. 
    trading_log를 통해 계산하거나 API에서 조회하여 얻을 수도 있지만, 빠른 조회를 위해 별도로 관리할 수 있습니다.
    SQL
    CREATE TABLE IF NOT EXISTS current_positions (
        stock_code VARCHAR(10) PRIMARY KEY COMMENT '종목 코드',
        current_size INT NOT NULL COMMENT '현재 보유 수량',
        average_price DECIMAL(15, 2) NOT NULL COMMENT '평균 매수 단가',
        entry_date DATE COMMENT '최초 진입일',
        highest_price_since_entry DECIMAL(15, 2) COMMENT '진입 이후 최고가 (손절 기준)',
        last_updated DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '최종 업데이트 시각'
    ) COMMENT='현재 보유 종목 포지션 (실시간 동기화 필요)';
 
    2. 전략 재활용 방안 - 기존 방식 변경
    기존 백테스트 Backtest 의 DailyStrategy와 MinuteStrategy의 로직은 TradingStrategy 로 통합된다. 
    즉, 전략에 따른 지표계산과 신호 발생, 이에 따른 자동매매 broker (Brokerage) 에 매매 실행을 위임하는 처리가 TradingStrategy 에서 모두 이루어지는 것으로 변경한다.
    이유는 전략과 전략에 따른 처리가 상관 관계가 있으므로 결합시키기 위해서다. 
    백테스트를 통한 파라미터 최적화 시에도 파라미터가 일봉전략, 분봉전략으로 나눠 지는 것 보다, 하나로 관리되는 것이 유리할 것읻다.
    핵심은 전략 인스턴스를 초기화할 때 주입되는 broker 객체를 자동매매 환경에 맞게 변경하는 것입니다.
    기존 백테스트 Backtest 에서는 data_store도 주입을 했었는데 그럴 필요없이 Trading 클래스 내부에서 TragingStrategy 와 Brokerage 가 Trading의 data_store 참조할 수 있도록,
    broker data_store 와 Trading data_store 연결은 Trading 초기화 시 주입받은 Brokerage broker.data_store = self.data_store 문장으로 연결 시킨다.  
    trading_strategy data_store 와 Trading data_store 연결은 Trading에 전략을 설정하는 메서드 set_trading_strategy 에서 TradingStategy strategy.data_store = self.data_store 문장으로 연결 시킨다.  
    기존 백테스트 Backtest 도 자동매매 Trading 처럼 일봉 분봉 매매전략을 TradingStrategy 하나로 통일하는 것으로 변경한다.
    이렇게 함으로써 백테스트 와 자동매매에서 동일한 매매전략을 공유 할 수 있도록 한다.
    Trading 초기화 시 db_manager, api_client 주입을 없애고 trading_manager 인스턴스를 주입받도록 수정합니다.
    그리고 broker 대신 Brokerage 인스턴스를 주입받도록 수정합니다.
    주입받은 trading_manager.py TradingManager 인스턴스의 db_manager, api_client 인스턴스 변수를 Trading 초기화 시 db_manager, api_client 인스턴스 변수에 대입합니다.

    generate_signals 메서드 내에서 필요한 과거 OHLCV 데이터는 trading_manager.get_historical_data()와 같은 메서드를 통해 DB에서 가져옵니다.
    신호 생성 후 trading_manager.save_daily_signals(self.signals)와 같은 메서드를 호출하여 daily_signals 테이블에 영구 저장합니다.
    시스템 재기동 시 generate_signals 메서드로 메모리상 signals 신호와 증권사 API(creon_api.py)를 통해 broker의 positions 를 복구합니다. 
    
    Trading는 장 시작 전 trading_manager.cache_daily_price()를 통해 daily_signals 테이블에 등록된 종목의 당일 매매에 필요한 일봉 데이터와 signal을 생성해 줍니다.
    execute_trading_logic 메서드 내에서 현재 가격이나 분봉 데이터가 필요할 경우, 
    trading_manager.get_realtime_ohlcv() 또는 trading_manager.get_realtime_minute_ohlcv()와 같은 메서드를 통해 실시간 데이터를 수신합니다.
    매수/매도 판단 시 self.broker.execute_order()를 호출하면 이제 실제 Brokerage의 주문 실행 로직이 동작하게 됩니다.
    
    3. 백테스팅과 자동매매의 차이점 반영
    사용자님께서 언급하신 두 가지 주요 차이점을 다음과 같이 반영합니다.

    시작-종료 방식 및 DB 통한 상태 교환:
    Trading는 매일 아침 시작하여 저녁에 종료되는 스케줄링된 프로세스가 됩니다.
    매일 시작 시 Trading와 Brokerage는 TradingManager를 통해 daily_signals, current_positions, daily_portfolio 등 전날까지의 모든 필요한 상태를 DB에서 로드합니다.
    장 중 발생하는 모든 주문 및 체결은 즉시 trading_log 테이블에 기록되어, 프로그램이 예기치 않게 종료되더라도 데이터 손실을 최소화하고 다음 시작 시 복구할 수 있도록 합니다.

    증권사 API 및 trading_manager:
    증권사 API(creon_api.py)는 실제 증권사 API와의 연동을 전담하며, 로그인, 시세 조회, 주문 전송, 잔고 조회 등의 기능을 제공합니다.
    trading_manager.py는 증권사 API(creon_api.py)와 DBManager 사이의 추상화 계층 역할을 하여, 
    Trading과 Brokerage가 복잡한 API 호출 및 DB 쿼리 로직을 직접 다루지 않고 필요한 데이터와 상태를 요청할 수 있도록 합니다. 이는 코드의 가독성과 유지보수성을 높입니다.
    
    4. 추가 고려사항 및 의견
    에러 핸들링 및 재시도: 실제 자동매매에서는 네트워크 오류, API 제한, 주문 실패 등 다양한 예외 상황이 발생할 수 있습니다. 
    Brokerage와 TradingManager 내에서 견고한 에러 핸들링 (로그 기록, 재시도 로직, 알림)이 필수적입니다.
    실시간 데이터 처리: 크레온 API의 실시간 데이터 수신 방식 (콜백 또는 폴링)을 고려하여 trading_manager 내에 효율적인 실시간 데이터 처리 파이프라인을 구축해야 합니다.
    시작 시간/종료 시간 관리: 장 시작 전 데이터 준비, 장 중 주문 가능 시간, 장 마감 후 정산 시간 등을 정확히 관리하는 스케줄러 기능이 Trading 또는 별도의 모듈에 필요합니다.
    주문 관리: 미체결 주문 처리, 주문 취소, 정정 주문 등의 로직도 Brokerage에서 고려되어야 합니다.
    보안: 민감한 API 키나 DB 비밀번호 등은 config/settings.py와 같은 별도의 설정 파일에서 안전하게 관리하고, 버전 관리 시스템에 직접 포함하지 않도록 주의해야 합니다.
    로깅: 모든 중요한 동작(데이터 수집, 신호 생성, 주문, 체결, 에러 등)에 대해 상세한 로깅을 구현하여 문제 발생 시 디버깅 및 사후 분석이 용이하도록 해야 합니다.
    이러한 설계에 따라 trading.py, trading_manager.py, create_trading_tables.sql 파일을 신규 개발하고, 
    brokerage.py 및 기존 전략 파일들을 수정한다면, 백테스팅과 자동매매 간의 효율적인 전환이 가능한 시스템을 구축할 수 있을 것입니다.

Q :
    개발 계획을 내가 생각한 방향으로 잘 이해하고 설계했다.
    실제로 자동매매를 개발할 때 사용했던 매매관련 증권사 api 파일을 첨부파일로 제공하겠다.
    이것을 이전에 백테스팅에 사용했던 creon_api 형식으로 메서드명, 메서드 인자, 내부처리, 리턴값의 데이터 형이 통일 되도록 수정되어야 할 것이다. 
    특히 일자, 시간 형식과 수치형은 float 형으로 통일해서 사용한다는 점 명심해라.
    1. 개발계획과 이번 채팅에서 첨부했던 파일을 참고해서 Trading (trading/trading.py), Brokerage(trading/brokerage.py), TradingManager (manager/trading_manager)
    2. 기존에 이미 개발된 자동매매 프로그램이 있으니까 관련 자료가 필요하면 요청해라.
    3. 추가로 불확실 하거나 나의 결정이 필요한 사항이 있으면, 나에게 물어 해결한 후 진행하라.

    위의 요구사항대로 진행해줘

A:
Python

# manager/trading_manager.py

import logging
import pandas as pd
from datetime import datetime, date, timedelta
import sys
import os
from typing import List, Dict, Any, Optional

# sys.path에 프로젝트 루트 추가 (db_manager 및 api 임포트를 위함)
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..')
sys.path.insert(0, project_root)

from manager.db_manager import DBManager
# 가정: 증권사 API(creon_api.py)는 실전용 Creon API Wrapper 클래스입니다.
# creon_api.py와 유사한 인터페이스를 가지도록 수정된 Creon.py에서 파생됩니다.
from api.creon_api_live import 증권사 API(creon_api.py) # 실제 파일명은 사용자 협의 후 결정

logger = logging.getLogger(__name__)

class TradeManager:
    def __init__(self, db_manager: DBManager, trading_manager: 증권사 API(creon_api.py)):
        self.db_manager = db_manager
        self.trading_manager = trading_manager
        logger.info("TradeManager 초기화 완료: DBManager 및 증권사 API(creon_api.py) 연결")

    def close(self):
        """DBManager의 연결을 종료합니다."""
        if self.db_manager:
            self.db_manager.close()
            logger.info("TradeManager를 통해 DB 연결을 종료했습니다.")

    def save_daily_signals(self, signals: Dict[str, Any], signal_date: date):
        """
        일봉 전략에서 생성된 매매 신호를 DB에 저장합니다.
        기존 데이터는 삭제 후 삽입 (덮어쓰기).
        """
        table_name = "daily_signals"
        # 이전 날짜의 신호 삭제
        self.db_manager.execute_sql(f"DELETE FROM {table_name} WHERE signal_date = '{signal_date.isoformat()}'")
        logger.info(f"이전 날짜({signal_date.isoformat()})의 일봉 신호 삭제 완료.")

        if not signals:
            logger.info(f"{signal_date.isoformat()}에 저장할 일봉 신호가 없습니다.")
            return

        data_to_insert = []
        for stock_code, signal_info in signals.items():
            data_to_insert.append({
                "signal_date": signal_date,
                "stock_code": stock_code,
                "signal_type": signal_info.get("signal_type"),
                "signal_price": float(signal_info.get("signal_price"),
                "volume_ratio": float(signal_info.get("volume_ratio", 0.0),
                "strategy_name": signal_info.get("strategy_name"),
                "params_json": str(signal_info.get("params_json", "{}") # 딕셔너리를 문자열로 저장
            })
        
        df = pd.DataFrame(data_to_insert)
        if not df.empty:
            if self.db_manager.insert_df_to_db(df, table_name, if_exists="append"):
                logger.info(f"{len(df)}개의 일봉 신호가 DB 테이블 '{table_name}'에 성공적으로 저장되었습니다.")
            else:
                logger.error(f"일봉 신호 {table_name} 저장에 실패했습니다.")
        else:
            logger.info(f"저장할 일봉 신호 데이터프레임이 비어 있습니다.")

    def load_daily_signals_for_today(self, signal_date: date) -> Dict[str, Any]:
        """
        주어진 날짜의 일봉 신호를 DB에서 로드합니다.
        """
        table_name = "daily_signals"
        query = f"SELECT * FROM {table_name} WHERE signal_date = '{signal_date.isoformat()}'"
        signals_df = self.db_manager.fetch_data(query)

        if signals_df.empty:
            logger.info(f"{signal_date.isoformat()}에 로드할 일봉 신호가 없습니다.")
            return {}

        loaded_signals = {}
        for _, row in signals_df.iterrows():
            stock_code = row['stock_code']
            loaded_signals[stock_code] = {
                "signal_type": row['signal_type'],
                "signal_price": float(row['signal_price']),
                "volume_ratio": float(row['volume_ratio']),
                "strategy_name": row['strategy_name'],
                "params_json": eval(row['params_json']) # 문자열을 딕셔너리로 다시 변환
            }
        logger.info(f"{len(loaded_signals)}개의 일봉 신호가 {signal_date.isoformat()}에 성공적으로 로드되었습니다.")
        return loaded_signals

    def save_trading_log(self, log_entry: Dict[str, Any]):
        """
        단일 거래 로그 항목을 DB의 transaction_log 테이블에 저장합니다.
        log_entry 예시: (date, stock_code, type, price, quantity, commission, net_amount, order_id, trading_type)
        """
        table_name = "transaction_log"
        df = pd.DataFrame([log_entry]) # 단일 항목을 DataFrame으로 변환

        if self.db_manager.insert_df_to_db(df, table_name, if_exists="append"):
            logger.info(f"거래 로그가 DB 테이블 '{table_name}'에 성공적으로 저장되었습니다: {log_entry.get('stock_code')} {log_entry.get('type')} {log_entry.get('quantity')}")
        else:
            logger.error(f"거래 로그 {table_name} 저장에 실패했습니다: {log_entry}")

    def save_daily_portfolio(self, snapshot_date: date, portfolio_value: float, cash: float, positions: Dict[str, Any]):
        """
        일일 포트폴리오 스냅샷을 DB에 저장합니다.
        """
        table_name = "daily_portfolio_snapshot"
        # 기존 날짜의 스냅샷 삭제 (덮어쓰기)
        self.db_manager.execute_sql(f"DELETE FROM {table_name} WHERE snapshot_date = '{snapshot_date.isoformat()}'")
        
        data_to_insert = {
            "snapshot_date": snapshot_date,
            "portfolio_value": float(portfolio_value),
            "cash": float(cash),
            "positions_json": str(positions) # positions 딕셔너리를 문자열로 저장
        }
        df = pd.DataFrame([data_to_insert])

        if self.db_manager.insert_df_to_db(df, table_name, if_exists="append"):
            logger.info(f"일일 포트폴리오 스냅샷이 DB 테이블 '{table_name}'에 성공적으로 저장되었습니다: {snapshot_date}, 가치: {portfolio_value:,.0f}")
        else:
            logger.error(f"일일 포트폴리오 스냅샷 {table_name} 저장에 실패했습니다.")

    def load_last_portfolio_snapshot(self) -> Optional[Dict[str, Any]]:
        """
        가장 최근의 포트폴리오 스냅샷을 DB에서 로드합니다.
        """
        table_name = "daily_portfolio_snapshot"
        query = f"SELECT * FROM {table_name} ORDER BY snapshot_date DESC LIMIT 1"
        snapshot_df = self.db_manager.fetch_data(query)

        if snapshot_df.empty:
            logger.info("로드할 포트폴리오 스냅샷이 없습니다.")
            return None

        snapshot = snapshot_df.iloc[0].to_dict()
        snapshot['positions_json'] = eval(snapshot['positions_json']) # 문자열을 딕셔너리로 변환
        logger.info(f"최근 포트폴리오 스냅샷 로드 완료: {snapshot['snapshot_date']}, 가치: {snapshot['portfolio_value']:,.0f}")
        return snapshot

    def save_current_positions(self, positions: Dict[str, Any]):
        """
        현재 보유 종목 정보를 DB에 저장 (실시간 동기화를 위해 사용).
        기존 데이터는 모두 삭제 후 현재 포지션으로 갱신.
        """
        table_name = "current_positions"
        # 기존 포지션 삭제
        self.db_manager.execute_sql(f"DELETE FROM {table_name}")
        logger.info("기존 보유 종목 정보 삭제 완료.")

        if not positions:
            logger.info("저장할 보유 종목 정보가 없습니다.")
            return

        data_to_insert = []
        for stock_code, position_info in positions.items():
            if position_info['size'] > 0: # 0주 이상인 포지션만 저장
                data_to_insert.append({
                    "stock_code": stock_code,
                    "size": int(position_info['size']),
                    "avg_price": float(position_info['avg_price']),
                    "entry_date": position_info['entry_date'],
                    "highest_price": float(position_info.get('highest_price', 0.0)
                })
        
        df = pd.DataFrame(data_to_insert)
        if not df.empty:
            if self.db_manager.insert_df_to_db(df, table_name, if_exists="append"):
                logger.info(f"{len(df)}개의 보유 종목 정보가 DB 테이블 '{table_name}'에 성공적으로 저장되었습니다.")
            else:
                logger.error(f"보유 종목 정보 {table_name} 저장에 실패했습니다.")
        else:
            logger.info(f"저장할 보유 종목 데이터프레임이 비어 있습니다.")

    def load_current_positions(self) -> Dict[str, Any]:
        """
        DB에서 현재 보유 종목 정보를 로드합니다.
        """
        table_name = "current_positions"
        query = f"SELECT * FROM {table_name}"
        positions_df = self.db_manager.fetch_data(query)

        loaded_positions = {}
        for _, row in positions_df.iterrows():
            stock_code = row['stock_code']
            loaded_positions[stock_code] = {
                "size": int(row['size']),
                "avg_price": float(row['avg_price']),
                "entry_date": row['entry_date'].date() if isinstance(row['entry_date'], datetime) else row['entry_date'],
                "highest_price": float(row['highest_price'])
            }
        logger.info(f"{len(loaded_positions)}개의 보유 종목 정보가 DB에서 로드되었습니다.")
        return loaded_positions
    
    def get_realtime_price(self, stock_code: str) -> Optional[float]:
        """
        실시간 현재가를 증권사 API(creon_api.py)를 통해 조회합니다.
        """
        price = self.trading_manager.get_current_price(stock_code)
        if price is not None:
            logger.debug(f"실시간 현재가 조회: {stock_code} - {price:,.0f}원")
        else:
            logger.warning(f"실시간 현재가 조회 실패: {stock_code}")
        return float(price) if price is not None else None

    def get_realtime_minute_data(self, stock_code: str) -> Optional[pd.DataFrame]:
        """
        실시간 1분봉 데이터를 증권사 API(creon_api.py)를 통해 조회합니다.
        DataFrame 형식으로 반환됩니다.
        """
        df = self.trading_manager.get_current_minute_data(stock_code)
        if df is not None and not df.empty:
            logger.debug(f"실시간 1분봉 데이터 조회: {stock_code}, {len(df)}개")
        else:
            logger.warning(f"실시간 1분봉 데이터 조회 실패 또는 없음: {stock_code}")
        return df

    def get_historical_ohlcv(self, stock_code: str, period: str, count: int) -> Optional[pd.DataFrame]:
        """
        증권사 API(creon_api.py)를 통해 과거 OHLCV 데이터를 조회합니다.
        백테스팅의 DataManager.get_historical_ohlcv와 유사하게 작동합니다.
        """
        df = self.trading_manager.get_price_data(stock_code, period, count)
        if df is not None and not df.empty:
            logger.debug(f"과거 OHLCV 데이터 조회: {stock_code}, 주기: {period}, 개수: {count}, {len(df)}개")
            # datetime 컬럼이 있으면 datetime.date로 변환
            if 'datetime' in df.columns:
                df['datetime'] = pd.to_datetime(df['datetime']).dt.date
            elif 'Date' in df.columns: # Creon.py의 get_price_data는 Date 컬럼을 반환하는 경향이 있음
                df['datetime'] = pd.to_datetime(df['Date']).dt.date
                df = df.rename(columns={'Open': 'open', 'High': 'high', 'Low': 'low', 'Close': 'close', 'Volume': 'volume'})
                df = df[['datetime', 'open', 'high', 'low', 'close', 'volume']] # 순서 조정 및 필요한 컬럼만 유지
        else:
            logger.warning(f"과거 OHLCV 데이터 조회 실패 또는 없음: {stock_code}, 주기: {period}, 개수: {count}")
        return df
    
    def get_all_stock_codes(self, market_type: Optional[str] = None) -> List[str]:
        """
        증권사 API(creon_api.py)를 통해 모든 또는 특정 시장의 종목 코드를 가져옵니다.
        """
        codes = self.trading_manager.get_all_stock_codes(market_type)
        logger.info(f"총 {len(codes)}개의 종목 코드 로드 완료 (시장: {market_type if market_type else '전체'})")
        return codes

    def update_market_calendar(self, from_date: date, to_date: date) -> bool:
        """
        증권사 API(creon_api.py)를 통해 거래일 캘린더를 업데이트하고 DB에 저장합니다.
        """
        logger.info(f"거래일 캘린더 업데이트 시작: {from_date} ~ {to_date}")
        trading_days = self.trading_manager.get_market_calendar(from_date, to_date)
        if trading_days:
            calendar_df = pd.DataFrame([{'trading_date': d} for d in trading_days])
            if self.db_manager.insert_df_to_db(calendar_df, "market_calendar", if_exists="append", index=False):
                logger.info(f"{len(trading_days)}개의 거래일이 market_calendar 테이블에 업데이트되었습니다.")
                return True
            else:
                logger.error("market_calendar 테이블 업데이트 실패.")
                return False
        logger.warning("Creon API에서 거래일 캘린더를 가져오지 못했습니다.")
        return False

    def update_stock_info(self, stock_code: str):
        """
        특정 종목의 최신 재무 데이터를 증권사 API(creon_api.py) (MarketEye)에서 가져와
        DB의 stock_info 테이블에 업데이트합니다.
        """
        logger.info(f"{stock_code} stock_info 테이블의 최신 재무 데이터 업데이트 중...")
        finance_df = self.trading_manager.get_latest_financial_data(stock_code)

        if finance_df.empty:
            logger.info(f"{stock_code} Creon API에서 조회된 재무 데이터가 없습니다.")
            return

        # MarketEye에서 가져온 DataFrame을 stock_info 테이블의 컬럼에 맞게 조정
        # 증권사 API(creon_api.py)에서 이미 백만 원 단위로 처리되었다고 가정
        # finance_df['operating_profit'] = finance_df['operating_profit'] / 1_000_000
        # finance_df['net_profit'] = finance_df['net_profit'] / 1_000_000

        # DBManager를 통해 UPSERT 실행 (stock_code 기준)
        if self.db_manager.insert_df_to_db(finance_df, "stock_info", if_exists="update", index=False, on_conflict_cols=['stock_code']):
            logger.info(f"{stock_code} 종목의 재무 데이터가 stock_info 테이블에 성공적으로 업데이트되었습니다.")
        else:
            logger.error(f"{stock_code} 종목의 재무 데이터 업데이트 실패.")

Python

# api/creon_api_live.py

import win32com.client
import ctypes
import time
import logging
import pandas as pd
import re
from datetime import datetime, date, timedelta
from typing import List, Dict, Any, Optional

API_REQUEST_INTERVAL = 0.2

logger = logging.getLogger(__name__)

class 증권사 API(creon_api.py):
    """
    실전 자동매매를 위한 Creon API Client Wrapper.
    백테스팅용 creon_api.py의 메서드 시그니처와 호환되도록 노력하며,
    Creon.py의 실시간 및 주문 기능을 통합합니다.
    """
    def __init__(self):
        self.connected = False
        self.cp_code_mgr = None
        self.cp_cybos = None
        self.cp_trading_util = None
        self.request_interval = API_REQUEST_INTERVAL
        self.stock_name_dic = {}
        self.stock_code_dic = {}
        self.account_number = None
        self.account_flag = None

        self._connect_creon()
        if self.connected:
            self.cp_code_mgr = win32com.client.Dispatch("CpUtil.CpCodeMgr")
            logger.info("CpCodeMgr COM object initialized.")
            self._make_stock_dic() # 종목 딕셔너리 미리 생성
            self._init_trading_module()

    def _connect_creon(self):
        """Creon Plus에 연결하고 COM 객체를 초기화합니다."""
        if ctypes.windll.shell32.IsUserAnAdmin():
            logger.info("Running with administrator privileges.")
        else:
            logger.warning("Not running with administrator privileges. Some Creon functions might be restricted.")

        try:
            self.cp_cybos = win32com.client.Dispatch("CpUtil.CpCybos")
            if self.cp_cybos.IsConnect == 0:
                logger.error("Creon Plus is not connected. Please connect Creon Plus first.")
                self.connected = False
                # exit() # 자동매매에서는 exit 대신 예외 처리 또는 재시도 로직 필요
                raise ConnectionError("Creon Plus is not connected.")
            self.connected = True
            logger.info("Creon Plus connected successfully.")
        except Exception as e:
            logger.error(f"Failed to connect to Creon Plus or initialize CpCybos: {e}", exc_info=True)
            self.connected = False

    def _init_trading_module(self):
        """주문 관련 모듈을 초기화하고 계좌 정보를 가져옵니다."""
        try:
            self.cp_trading_util = win32com.client.Dispatch('CpTrade.CpTdUtil')
            if self.cp_trading_util.TradeInit(0) != 0:
                logger.error("Trade module initialization failed!")
                raise RuntimeError("Creon TradeInit failed.")

            self.account_number = self.cp_trading_util.AccountNumber[0]
            self.account_flag = self.cp_trading_util.GoodsList(self.account_number, 1)[0] # 주식상품 구분
            logger.info(f"Creon API Trade Module initialized. Account: {self.account_number}, Flag: {self.account_flag}")
        except Exception as e:
            logger.error(f"Failed to initialize trading module or get account info: {e}", exc_info=True)
            raise

    def is_connected(self) -> bool:
        """Creon API 연결 상태를 반환합니다."""
        if not self.cp_cybos:
            return False
        return True if self.cp_cybos.IsConnect == 1 else False

    def _is_spac(self, code_name: str) -> bool:
        return re.search(r'\d+호', code_name) is not None

    def _is_preferred_stock(self, code_name: str) -> bool:
        return re.search(r'([0-9]+우|우[A-Z]?)$', code_name) is not None and len(code_name) >= 3

    def _is_reits(self, code_name: str) -> bool:
        return "리츠" in code_name

    def _make_stock_dic(self):
        """전체 종목 코드와 이름을 딕셔너리로 저장합니다."""
        if not self.cp_code_mgr:
            logger.error("CpCodeMgr is not initialized. Cannot make stock dictionary.")
            return

        logger.info("Generating stock code/name dictionaries...")
        try:
            kospi_codes = self.cp_code_mgr.GetStockListByMarket(1)
            kosdaq_codes = self.cp_code_mgr.GetStockListByMarket(2)
            all_codes = kospi_codes + kosdaq_codes

            for code in all_codes:
                code_name = self.cp_code_mgr.CodeToName(code)
                section_kind = str(self.cp_code_mgr.GetStockSectionKind(code)
                if section_kind != '1' or self._is_spac(code_name) or self._is_preferred_stock(code_name) or self._is_reits(code_name):
                    continue
                self.stock_name_dic[code_name] = code
                self.stock_code_dic[code] = code_name
            logger.info(f"Finished generating stock code/name dictionaries. Total {len(self.stock_code_dic)} valid stocks.")
        except Exception as e:
            logger.error(f"Error making stock dictionary: {e}", exc_info=True)

    def get_all_stock_codes(self, market_type: Optional[str] = None) -> List[str]:
        """
        모든 또는 특정 시장의 종목 코드를 반환합니다.
        market_type: 'KOSPI', 'KOSDAQ', 또는 None (전체).
        """
        if market_type == 'KOSPI':
            return self.cp_code_mgr.GetStockListByMarket(1)
        elif market_type == 'KOSDAQ':
            return self.cp_code_mgr.GetStockListByMarket(2)
        else: # All markets
            return list(self.stock_code_dic.keys()

    def get_stock_name_by_code(self, stock_code: str) -> Optional[str]:
        """종목 코드로 종목명을 조회합니다."""
        return self.stock_code_dic.get(stock_code)

    def get_stock_code_by_name(self, stock_name: str) -> Optional[str]:
        """종목명으로 종목 코드를 조회합니다."""
        return self.stock_name_dic.get(stock_name)

    def get_market_calendar(self, from_date: date, to_date: date, stock_code: str = 'A005930') -> List[date]:
        """
        주어진 기간 동안의 거래일 캘린더를 조회합니다.
        (백테스팅 creon_api.py의 get_market_calendar와 동일)
        """
        logger.info(f"Fetching market calendar from {from_date} to {to_date} using {stock_code}")
        
        # CpSysDib.StockChart 객체 사용
        objChart = win32com.client.Dispatch("CpSysDib.StockChart")
        objChart.SetInputValue(0, stock_code) # 종목코드
        objChart.SetInputValue(1, ord('1')   # 기간으로 조회
        objChart.SetInputValue(2, to_date.strftime('%Y%m%d') # To Date
        objChart.SetInputValue(3, from_date.strftime('%Y%m%d') # From Date
        objChart.SetInputValue(5, [0]) # 날짜 필드만 요청
        objChart.SetInputValue(6, ord('D') # 일봉
        objChart.SetInputValue(9, ord('1') # 수정주가 사용
        
        trading_days = []
        while True:
            ret = objChart.BlockRequest()
            if ret != 0:
                logger.error(f"BlockRequest failed for market calendar: {ret}")
                break
            
            status = objChart.GetDibStatus()
            msg = objChart.GetDibMsg1()
            if status != 0:
                logger.error(f"Market calendar request error: Status={status}, Msg={msg}")
                break

            count = objChart.GetHeaderValue(3) # 수신개수
            for i in range(count):
                date_str = str(objChart.GetDataValue(0, i)
                trading_days.append(datetime.strptime(date_str, '%Y%m%d').date()
            
            if objChart.Continue: # 연속 데이터 여부
                time.sleep(self.request_interval)
            else:
                break
        
        trading_days.sort() # 날짜 순으로 정렬
        logger.info(f"Found {len(trading_days)} trading days.")
        return trading_days

    def get_price_data(self, stock_code: str, period: str, count: int) -> Optional[pd.DataFrame]:
        """
        과거 OHLCV 데이터를 조회합니다.
        (백테스팅 creon_api.py의 _get_price_data와 유사하게 통합)
        period: 'D' (일), 'W' (주), 'M' (월), 'm' (분), 'T' (틱)
        count: 조회할 데이터 개수 (최근으로부터)
        """
        logger.info(f"Fetching price data for {stock_code}, period: {period}, count: {count}")
        objChart = win32com.client.Dispatch("CpSysDib.StockChart")
        objChart.SetInputValue(0, stock_code)
        objChart.SetInputValue(1, ord('2') # '개수'로 조회
        objChart.SetInputValue(4, count)    # 조회할 개수
        objChart.SetInputValue(6, ord(period) # 주기
        objChart.SetInputValue(9, ord('1') # 수정주가 사용

        # 요청 항목 설정 (Creon.py의 get_price_data 로직 따름)
        if period == 'm' or period == 'T':
            objChart.SetInputValue(5, [0, 1, 2, 3, 4, 5, 8]) # 날짜, 시간, 시가, 고가, 저가, 종가, 거래량
            if period == 'm':
                objChart.SetInputValue(7, 1) # 1분봉
        else:
            objChart.SetInputValue(5, [0, 2, 3, 4, 5, 8]) # 날짜, 시가, 고가, 저가, 종가, 거래량
        
        ret = objChart.BlockRequest()
        if ret != 0:
            logger.error(f"BlockRequest failed for price data {stock_code}: {ret}")
            return None
        
        status = objChart.GetDibStatus()
        msg = objChart.GetDibMsg1()
        if status != 0:
            logger.error(f"Price data request error {stock_code}: Status={status}, Msg={msg}")
            return None

        columns = ['Date', 'Time', 'Open', 'High', 'Low', 'Close', 'Volume'] if period in ['m', 'T'] else ['Date', 'Open', 'High', 'Low', 'Close', 'Volume']
        data = []

        cnt = objChart.GetHeaderValue(3) # 수신 개수
        for i in range(cnt):
            row = []
            row.append(str(objChart.GetDataValue(0, i)) # Date
            if period in ['m', 'T']:
                row.append(str(objChart.GetDataValue(1, i)) # Time
                row.append(float(objChart.GetDataValue(2, i)) # Open
                row.append(float(objChart.GetDataValue(3, i)) # High
                row.append(float(objChart.GetDataValue(4, i)) # Low
                row.append(float(objChart.GetDataValue(5, i)) # Close
                row.append(float(objChart.GetDataValue(6, i)) # Volume (Index 8 in SetInputValue means 6th column in GetDataValue after date/time)
            else:
                row.append(float(objChart.GetDataValue(1, i)) # Open
                row.append(float(objChart.GetDataValue(2, i)) # High
                row.append(float(objChart.GetDataValue(3, i)) # Low
                row.append(float(objChart.GetDataValue(4, i)) # Close
                row.append(float(objChart.GetDataValue(5, i)) # Volume

            data.append(row)
        
        df = pd.DataFrame(data, columns=columns)
        
        if period in ['m', 'T']:
            # 'Date'와 'Time'을 결합하여 'datetime'으로 변환
            df['datetime'] = pd.to_datetime(df['Date'] + df['Time'].astype(str).str.zfill(6), format='%Y%m%d%H%M%S')
        else:
            df['datetime'] = pd.to_datetime(df['Date'], format='%Y%m%d')

        # 필요한 컬럼만 남기고 이름 통일
        df = df[['datetime', 'Open', 'High', 'Low', 'Close', 'Volume']]
        df.rename(columns={'Open': 'open', 'High': 'high', 'Low': 'low', 'Close': 'close', 'Volume': 'volume'}, inplace=True)
        
        df.sort_values(by='datetime', inplace=True)
        df.set_index('datetime', inplace=True)
        
        logger.info(f"Successfully fetched {len(df)} rows of price data for {stock_code}.")
        return df

    def get_current_price(self, stock_code: str) -> Optional[float]:
        """
        실시간 현재가를 조회합니다 (CpSysDib.StockMst 사용).
        """
        logger.debug(f"Fetching current price for {stock_code}")
        try:
            objStockMst = win32com.client.Dispatch("CpSysDib.StockMst")
            objStockMst.SetInputValue(0, stock_code)
            
            ret = objStockMst.BlockRequest()
            if ret == 0:
                # 필드 10: 현재가 (종가)
                current_price = float(objStockMst.GetHeaderValue(11) # 종가 (실시간은 보통 현재가와 동일)
                logger.debug(f"Current price for {stock_code}: {current_price}")
                return current_price
            else:
                logger.error(f"BlockRequest failed for current price {stock_code}: {ret}")
                return None
        except Exception as e:
            logger.error(f"Error fetching current price for {stock_code}: {e}", exc_info=True)
            return None

    def get_current_minute_data(self, stock_code: str, count: int = 1) -> Optional[pd.DataFrame]:
        """
        실시간 1분봉 데이터를 조회합니다 (get_price_data 재활용).
        실시간 스트리밍이 아닌 요청 시점의 가장 최신 1분봉 데이터를 가져오는 방식.
        """
        logger.debug(f"Fetching current minute data for {stock_code}, count={count}")
        # CpSysDib.StockChart의 1분봉 조회 기능을 활용
        df = self.get_price_data(stock_code, 'm', count)
        if df is not None and not df.empty:
            # 가장 최근 데이터만 필요하다면 (count=1 기준)
            # df = df.tail(1)
            return df
        return None

    def get_latest_financial_data(self, stock_code: str) -> pd.DataFrame:
        """
        종목의 최신 재무 데이터를 조회합니다 (CpSysDib.MarketEye 사용).
        백테스팅의 creon_api.py의 get_latest_financial_data와 유사하게 구현.
        """
        logger.info(f"Fetching latest financial data for {stock_code}")
        objMarketEye = win32com.client.Dispatch("CpSysDib.MarketEye")
        
        # 요청할 필드 설정 (주가, 재무제표 관련)
        # CpSysDib.MarketEye.Get
        # 1: 종목코드, 4: 종목명, 11:현재가, 20:PER, 21:PBR, 22:EPS, 67:ROE, 70:부채비율
        # 110: 매출액(억), 111: 영업이익(억), 112: 당기순이익(억) (최근 분기)
        # 161: 최근 결산년월
        req_fields = [
            0, # 종목코드
            1, # 종목명
            11, # 현재가
            20, # PER
            21, # PBR
            22, # EPS
            67, # ROE
            70, # 부채비율
            110, # 매출액
            111, # 영업이익
            112, # 당기순이익
            161 # 최근 결산년월
        ]
        
        objMarketEye.SetInputValue(0, req_fields) # 요청 필드
        objMarketEye.SetInputValue(1, stock_code) # 종목 코드
        
        ret = objMarketEye.BlockRequest()
        if ret != 0:
            logger.error(f"BlockRequest failed for financial data {stock_code}: {ret}")
            return pd.DataFrame() # 빈 DataFrame 반환
        
        status = objMarketEye.GetDibStatus()
        msg = objMarketEye.GetDibMsg1()
        if status != 0:
            logger.error(f"Financial data request error {stock_code}: Status={status}, Msg={msg}")
            return pd.DataFrame()

        # 데이터 파싱
        stock_code_res = objMarketEye.GetHeaderValue(0)
        stock_name_res = objMarketEye.GetHeaderValue(1)
        current_price = objMarketEye.GetHeaderValue(2)
        per = objMarketEye.GetHeaderValue(3)
        pbr = objMarketEye.GetHeaderValue(4)
        eps = objMarketEye.GetHeaderValue(5)
        roe = objMarketEye.GetHeaderValue(6)
        debt_ratio = objMarketEye.GetHeaderValue(7)
        sales = objMarketEye.GetHeaderValue(8) * 100_000_000 # 억 단위를 원 단위로
        operating_profit = objMarketEye.GetHeaderValue(9) * 100_000_000
        net_profit = objMarketEye.GetHeaderValue(10) * 100_000_000
        recent_financial_date_str = str(objMarketEye.GetHeaderValue(11) # YYYYMM

        recent_financial_date = None
        if len(recent_financial_date_str) == 6:
            try:
                recent_financial_date = datetime.strptime(recent_financial_date_str, '%Y%m').date()
            except ValueError:
                logger.warning(f"Could not parse financial date: {recent_financial_date_str}")
        
        data = [{
            'stock_code': stock_code_res,
            'stock_name': stock_name_res,
            'current_price': float(current_price),
            'per': float(per) if per != 0 else None,
            'pbr': float(pbr) if pbr != 0 else None,
            'eps': float(eps) if eps != 0 else None,
            'roe': float(roe) if roe != 0 else None,
            'debt_ratio': float(debt_ratio) if debt_ratio != 0 else None,
            'sales': float(sales),
            'operating_profit': float(operating_profit),
            'net_profit': float(net_profit),
            'recent_financial_date': recent_financial_date
        }]
        
        df = pd.DataFrame(data)
        logger.info(f"Successfully fetched financial data for {stock_code}.")
        return df

    # --- 주문 관련 메서드 ---
    def send_order(self, stock_code: str, order_type: str, price: float, quantity: int, order_kind: str = '01', org_order_no: str = '') -> Optional[str]:
        """
        주문 전송 (매수/매도/정정/취소).
        order_type: 'buy', 'sell'
        order_kind: '01'(보통), '03'(시장가) 등 Creon 주문 종류 코드
        org_order_no: 정정/취소 시 원주문번호
        """
        if not self.connected:
            logger.error("Creon API is not connected. Cannot send order.")
            return None

        objOrder = win32com.client.Dispatch("CpTrade.CpTd0311")
        
        # 입력 값 설정
        objOrder.SetInputValue(0, order_kind) # 주문 종류: 01-보통, 03-시장가
        objOrder.SetInputValue(1, self.account_number) # 계좌번호
        objOrder.SetInputValue(2, self.account_flag) # 상품구분
        objOrder.SetInputValue(3, stock_code) # 종목코드
        objOrder.SetInputValue(4, int(quantity) # 주문수량
        objOrder.SetInputValue(5, int(price) # 주문단가 (시장가는 의미 없음)

        if order_type == 'buy':
            objOrder.SetInputValue(6, ord('2') # '2': 매수
        elif order_type == 'sell':
            objOrder.SetInputValue(6, ord('1') # '1': 매도
        else:
            logger.error(f"Unsupported order type: {order_type}")
            return None
        
        # '보통' 주문 시에만 유효한 가격 필드
        # objOrder.SetInputValue(7, "0")  # '0': 주문조건 구분 코드 (없음)
        # objOrder.SetInputValue(8, "01") # '01': 신용주문 구분코드 (대출,신용 등은 01:보통)

        # 정정/취소 주문 시 원주문번호 필요
        if org_order_no:
            objOrder.SetInputValue(9, org_order_no) # 원주문번호 (정정/취소 시 사용)

        # 주문 요청
        ret = objOrder.BlockRequest()
        if ret != 0:
            logger.error(f"Order BlockRequest failed for {stock_code} {order_type} {quantity}@{price}: {ret}")
            return None
        
        status = objOrder.GetDibStatus()
        msg = objOrder.GetDibMsg1()
        if status != 0:
            logger.error(f"Order request error for {stock_code}: Status={status}, Msg={msg}")
            return None

        # 주문 성공 시 반환 값
        # GetHeaderValue(4) : 주문번호
        # GetHeaderValue(5) : 주문수량
        order_id = str(objOrder.GetHeaderValue(4)
        order_qty = int(objOrder.GetHeaderValue(5)
        logger.info(f"Order sent successfully: {order_type.upper()} {stock_code}, Qty: {order_qty}, Price: {price}, OrderID: {order_id}")
        return order_id

    def get_account_balance(self) -> Dict[str, float]:
        """
        계좌 잔고 (현금) 및 예수금 정보를 조회합니다.
        """
        logger.debug("Fetching account balance...")
        try:
            objCash = win32com.client.Dispatch("CpTrade.CpTdNew5331A")
            objCash.SetInputValue(0, self.account_number)
            objCash.SetInputValue(1, self.account_flag)
            
            ret = objCash.BlockRequest()
            if ret != 0:
                logger.error(f"BlockRequest failed for account balance: {ret}")
                return {"cash": 0.0, "deposit": 0.0}

            status = objCash.GetDibStatus()
            msg = objCash.GetDibMsg1()
            if status != 0:
                logger.error(f"Account balance request error: Status={status}, Msg={msg}")
                return {"cash": 0.0, "deposit": 0.0}

            # 예수금, 매도 가능 금액 등 조회
            cash = float(objCash.GetHeaderValue(9) # 주문가능금액
            deposit = float(objCash.GetHeaderValue(13) # 예수금
            logger.info(f"Account Balance: Cash={cash:,.0f}, Deposit={deposit:,.0f}")
            return {"cash": cash, "deposit": deposit}
        except Exception as e:
            logger.error(f"Error fetching account balance: {e}", exc_info=True)
            return {"cash": 0.0, "deposit": 0.0}

    def get_portfolio_positions(self) -> List[Dict[str, Any]]:
        """
        현재 보유 종목 리스트 및 상세 정보를 조회합니다.
        """
        logger.debug("Fetching portfolio positions...")
        try:
            objRp = win32com.client.Dispatch("CpTrade.CpTd6033")
            objRp.SetInputValue(0, self.account_number)
            objRp.SetInputValue(1, self.account_flag)
            objRp.SetInputValue(2, 50) # 요청할 개수 (최대 50개)

            positions = []
            while True:
                ret = objRp.BlockRequest()
                if ret != 0:
                    logger.error(f"BlockRequest failed for portfolio positions: {ret}")
                    break

                status = objRp.GetDibStatus()
                msg = objRp.GetDibMsg1()
                if status != 0:
                    logger.error(f"Portfolio positions request error: Status={status}, Msg={msg}")
                    break

                cnt = objRp.GetHeaderValue(7) # 수신 개수
                for i in range(cnt):
                    stock_code = objRp.GetDataValue(12, i) # 종목코드
                    stock_name = objRp.GetDataValue(0, i) # 종목명
                    current_qty = int(objRp.GetDataValue(7, i) # 잔고수량
                    avg_price = float(objRp.GetDataValue(9, i) # 매입단가
                    
                    # 현재가는 별도로 조회 필요 (StockMst 사용)
                    # 여기서는 일단 잔고 정보만 가져오고, 현재가는 TradeManager에서 별도로 호출
                    positions.append({
                        'stock_code': stock_code,
                        'stock_name': stock_name,
                        'size': current_qty,
                        'avg_price': avg_price
                    })

                if not objRp.Continue: # 연속 데이터가 없으면
                    break
                time.sleep(self.request_interval)

            logger.info(f"Fetched {len(positions)} portfolio positions.")
            return positions
        except Exception as e:
            logger.error(f"Error fetching portfolio positions: {e}", exc_info=True)
            return []

    def get_order_status(self, order_id: str) -> Dict[str, Any]:
        """
        특정 주문의 체결 상태를 조회합니다 (CpTrade.CpTd0311 - 주문확인).
        order_id: 주문번호
        """
        logger.debug(f"Fetching order status for order ID: {order_id}")
        try:
            objReq = win32com.client.Dispatch("CpTrade.CpTd0311")
            objReq.SetInputValue(0, self.account_number)
            objReq.SetInputValue(1, self.account_flag)
            objReq.SetInputValue(2, order_id) # 원주문번호 (조회할 주문번호)

            ret = objReq.BlockRequest()
            if ret != 0:
                logger.error(f"BlockRequest failed for order status {order_id}: {ret}")
                return {"status": "ERROR", "message": f"BlockRequest failed: {ret}"}
            
            status = objReq.GetDibStatus()
            msg = objReq.GetDibMsg1()
            if status != 0:
                logger.error(f"Order status request error {order_id}: Status={status}, Msg={msg}")
                return {"status": "ERROR", "message": f"API error: {msg}"}

            # 반환 필드 확인 (CpTrade.CpTd0311 설명서 참고)
            # 1: 주문상태 (접수, 체결, 확인, 거부 등)
            # 5: 체결수량
            # 6: 체결가격
            order_status = objReq.GetHeaderValue(1)
            executed_qty = int(objReq.GetHeaderValue(5)
            executed_price = float(objReq.GetHeaderValue(6)

            logger.info(f"Order {order_id} Status: {order_status}, Executed Qty: {executed_qty}, Price: {executed_price}")
            return {
                "status": order_status,
                "executed_quantity": executed_qty,
                "executed_price": executed_price
            }
        except Exception as e:
            logger.error(f"Error fetching order status for {order_id}: {e}", exc_info=True)
            return {"status": "ERROR", "message": str(e)}

Python

# trading/brokerage.py

import datetime
import logging
from typing import Dict, Any
from backtest.abstract_broker import AbstractBroker
from api.creon_api_live import 증권사 API(creon_api.py) # 실전 API 클라이언트
from manager.trading_manager import TradeManager # TradeManager 추가

logger = logging.getLogger(__name__)

class Brokerage(AbstractBroker):
    """
    실전 자동매매를 위한 증권사 브로커 클래스.
    AbstractBroker를 상속받아 실제 증권사 API 연동을 구현합니다.
    """
    def __init__(self, trading_manager: 증권사 API(creon_api.py), trading_manager: TradeManager, 
                 commission_rate: float = 0.0003, slippage_rate: float = 0.0):
        self.trading_manager = trading_manager
        self.trading_manager = trading_manager
        self.commission_rate = commission_rate
        self.slippage_rate = slippage_rate
        self.stop_loss_params = None
        
        # 실전에서는 초기 현금과 포지션을 API에서 조회하여 동기화
        self.cash = 0.0
        self.positions = {}  # {stock_code: {'size': int, 'avg_price': float, 'entry_date': datetime.date, 'highest_price': float}}
        self.initial_portfolio_value = 0.0 # 포트폴리오 손절을 위한 초기값 (일일 초기화 필요)
        self.transaction_log = [] # (date, stock_code, type, price, quantity, commission, net_amount, order_id, trading_type)
        
        self.sync_account_info() # 초기화 시 계좌 정보 동기화
        logger.info(f"Brokerage 초기화 완료: 초기 현금 {self.cash:,.0f}원, 수수료율 {self.commission_rate*100:.2f}%")

    def sync_account_info(self):
        """
        증권사 API로부터 최신 현금 잔고와 보유 종목 정보를 동기화합니다.
        매매 시작 전, 그리고 주기적으로 호출하여 최신 정보를 반영합니다.
        """
        if not self.trading_manager.is_connected():
            logger.error("Creon API is not connected. Cannot sync account info.")
            return False

        # 현금 잔고 동기화
        balance = self.trading_manager.get_account_balance()
        if balance:
            self.cash = float(balance.get("cash", 0.0)
            logger.info(f"계좌 현금 잔고 동기화 완료: {self.cash:,.0f}원")
        else:
            logger.error("계좌 현금 잔고 동기화 실패.")
            return False

        # 보유 종목 동기화
        live_positions_list = self.trading_manager.get_portfolio_positions()
        new_positions = {}
        for pos in live_positions_list:
            stock_code = pos['stock_code']
            # 실전에서는 진입일, 최고가 등의 정보는 DB에서 로드하거나 별도 관리 필요.
            # 여기서는 API에서 제공하는 정보만으로 업데이트.
            # 백테스팅과 필드 통일을 위해 avg_price, size, entry_date, highest_price 키 사용
            # entry_date, highest_price는 DB나 TradeManager에서 로드해야 함
            loaded_pos = self.trading_manager.load_current_positions().get(stock_code, {})
            new_positions[stock_code] = {
                'size': int(pos['size']),
                'avg_price': float(pos['avg_price']),
                'entry_date': loaded_pos.get('entry_date', datetime.date.today(), # 임시 기본값, DB에서 로드 권장
                'highest_price': loaded_pos.get('highest_price', float(pos['avg_price']) # 임시 기본값, DB에서 로드 권장
            }
        self.positions = new_positions
        self.trading_manager.save_current_positions(self.positions) # 동기화된 포지션 DB 저장
        logger.info(f"보유 종목 정보 동기화 완료: 총 {len(self.positions)}개 종목 보유 중.")
        return True

    def execute_order(self, stock_code: str, order_type: str, price: float, quantity: int, current_dt: datetime, order_kind: str = '01'):
        """
        주문을 실행하고 거래 로그를 기록합니다.
        실전에서는 실제 증권사 API를 통해 주문을 전송합니다.
        price는 보통가 주문 시 사용, 시장가 주문 시에는 무시될 수 있습니다.
        """
        if not self.trading_manager.is_connected():
            logger.error("Creon API is not connected. Order execution failed.")
            return

        # 슬리피지 적용 (실전에서는 호가창 분석 후 실제 체결가 결정 로직 추가 가능)
        actual_price = price
        if order_type == 'buy':
            actual_price = price * (1 + self.slippage_rate)
        elif order_type == 'sell':
            actual_price = price * (1 - self.slippage_rate)
        
        # 수수료 계산
        commission = actual_price * quantity * self.commission_rate
        net_amount = (actual_price * quantity) + commission if order_type == 'buy' else (actual_price * quantity) - commission

        logger.info(f"[주문 요청] {current_dt.isoformat()} - {stock_code} {order_type.upper()} {quantity}주 @ {actual_price:,.0f}원 (원가: {price:,.0f}원)")
        
        order_id = self.trading_manager.send_order(stock_code, order_type, actual_price, quantity, order_kind)

        if order_id:
            logger.info(f"주문 성공: {stock_code}, 주문번호: {order_id}. 체결 대기 중...")
            
            # TODO: 실제 체결 여부 및 체결가 확인 로직 필요 (실시간 수신 또는 주기적 조회)
            # 지금은 주문 성공 시 바로 로그에 기록하지만, 실제 자동매매는 비동기 처리 또는 콜백으로 체결 확인
            
            # 현재는 주문 요청 성공 시 즉시 로그에 기록 (최소한의 구현)
            log_entry = {
                "date": current_dt.date(),
                "datetime": current_dt,
                "stock_code": stock_code,
                "type": order_type,
                "price": float(actual_price), # 체결가로 기록
                "quantity": int(quantity),
                "commission": float(commission),
                "net_amount": float(net_amount),
                "order_id": order_id,
                "trading_type": order_kind # '01' 보통, '03' 시장가 등
            }
            self.transaction_log.append(log_entry)
            self.trading_manager.save_trading_log(log_entry) # DB에 로그 저장

            # 포지션 업데이트 (가정된 체결) - 실제 체결가/수량으로 업데이트 필요
            if order_type == 'buy':
                if stock_code in self.positions:
                    current_total_value = self.positions[stock_code]['size'] * self.positions[stock_code]['avg_price']
                    new_size = self.positions[stock_code]['size'] + quantity
                    new_avg_price = (current_total_value + (actual_price * quantity) / new_size
                    self.positions[stock_code]['size'] = new_size
                    self.positions[stock_code]['avg_price'] = new_avg_price
                    self.positions[stock_code]['highest_price'] = max(self.positions[stock_code]['highest_price'], actual_price) # 매수 시 최고가 갱신
                else:
                    self.positions[stock_code] = {
                        'size': quantity,
                        'avg_price': actual_price,
                        'entry_date': current_dt.date(),
                        'highest_price': actual_price # 매수 시 최고가
                    }
                self.cash -= net_amount
            elif order_type == 'sell':
                if stock_code in self.positions:
                    self.cash += net_amount
                    self.positions[stock_code]['size'] -= quantity
                    if self.positions[stock_code]['size'] <= 0:
                        del self.positions[stock_code] # 전량 매도 시 포지션 삭제
                else:
                    logger.warning(f"보유하지 않은 종목 {stock_code}에 대한 매도 요청입니다.")
            
            self.trading_manager.save_current_positions(self.positions) # DB에 현재 포지션 저장
            logger.info(f"거래 후 현금 잔고: {self.cash:,.0f}원")

        else:
            logger.error(f"주문 실패: {stock_code} {order_type} {quantity}주 @ {actual_price:,.0f}원")

    def get_position_size(self, stock_code: str) -> int:
        """현재 보유한 특정 종목의 수량을 반환합니다."""
        # 실전에서는 실시간으로 API에서 조회하는 것이 정확하지만, 빈번한 호출을 피하기 위해
        # 동기화된 self.positions를 활용하고 주기적으로 sync_account_info를 호출하는 방식.
        return self.positions.get(stock_code, {}).get('size', 0)

    def get_portfolio_value(self, current_prices: Dict[str, float]) -> float:
        """현재 포트폴리오의 총 가치를 계산하여 반환합니다."""
        total_value = self.cash
        for stock_code, position in self.positions.items():
            if stock_code in current_prices:
                total_value += position['size'] * current_prices[stock_code]
            else:
                logger.warning(f"현재 가격을 알 수 없는 종목 {stock_code}이 포트폴리오에 포함되어 있습니다. 계산에서 제외.")
        return total_value

    def set_stop_loss_params(self, stop_loss_params: Dict[str, Any]):
        """손절매 관련 파라미터를 설정합니다."""
        if stop_loss_params is None:
            return
        self.stop_loss_params = stop_loss_params
        logger.info(f"Brokerage 손절매 파라미터 설정 완료: {stop_loss_params}")

    def check_and_execute_stop_loss(self, stock_code: str, current_price: float, current_dt: datetime) -> bool:
        """
        개별 종목에 대한 손절매 조건을 확인하고, 조건 충족 시 손절매 주문을 실행합니다.
        (백테스팅의 Broker와 동일한 로직을 가지도록 구현)
        """
        if not self.stop_loss_params or stock_code not in self.positions:
            return False

        position = self.positions[stock_code]
        avg_price = position['avg_price']
        highest_price = position['highest_price']
        current_size = position['size']

        if current_size <= 0:
            return False

        loss_ratio = self._calculate_loss_ratio(current_price, avg_price)
        trailing_stop_loss_ratio = self.stop_loss_params.get('trailing_stop_loss_ratio')

        # 1. 고정 손절매
        if 'stop_loss_ratio' in self.stop_loss_params and loss_ratio <= self.stop_loss_params['stop_loss_ratio']:
            logger.warning(f"[개별 손절매] {current_dt.isoformat()} - {stock_code}: 손실율 {loss_ratio*100:.2f}% (기준: {self.stop_loss_params['stop_loss_ratio']*100:.2f}%)")
            self.execute_order(stock_code, 'sell', current_price, current_size, current_dt, order_kind='03') # 시장가 매도
            return True

        # 2. 트레일링 스탑
        if trailing_stop_loss_ratio and highest_price > 0:
            # 최고가 대비 현재가 하락률
            trailing_loss_from_peak = (highest_price - current_price) / highest_price
            if trailing_loss_from_peak >= trailing_stop_loss_ratio:
                logger.warning(f"[트레일링 스탑] {current_dt.isoformat()} - {stock_code}: 최고가({highest_price:,.0f}원) 대비 {trailing_loss_from_peak*100:.2f}% 하락 (기준: {trailing_stop_loss_ratio*100:.2f}%)")
                self.execute_order(stock_code, 'sell', current_price, current_size, current_dt, order_kind='03') # 시장가 매도
                return True
            else:
                # 현재가가 최고가보다 높으면 최고가 갱신
                self.positions[stock_code]['highest_price'] = max(highest_price, current_price)
        return False

    def _calculate_loss_ratio(self, current_price: float, avg_price: float) -> float:
        """손실율을 계산합니다 (양수: 이득, 음수: 손실)."""
        if avg_price == 0:
            return 0.0 # 매입 단가가 0일 경우 (예: 무상증자 등으로 취득)
        return (current_price - avg_price) / avg_price

    def check_and_execute_portfolio_stop_loss(self, current_prices: Dict[str, float], current_dt: datetime) -> bool:
        """
        포트폴리오 전체 손절매 조건을 확인하고, 조건 충족 시 전체 청산을 실행합니다.
        (백테스팅의 Broker와 동일한 로직을 가지도록 구현)
        """
        if not self.stop_loss_params or not self.stop_loss_params.get('max_losing_positions'):
            return False

        losing_positions_count = 0
        for stock_code, position in self.positions.items():
            if position['size'] > 0 and stock_code in current_prices:
                loss_ratio = self._calculate_loss_ratio(current_prices[stock_code], position['avg_price'])
                if loss_ratio <= self.stop_loss_params['stop_loss_ratio']: # 포트폴리오 손절 시 개별 손절율 기준 사용
                    losing_positions_count += 1

        if losing_positions_count >= self.stop_loss_params['max_losing_positions']:
            logger.warning(f'[포트폴리오 손절] {current_dt.isoformat()} - 손실 종목 수: {losing_positions_count}개 (기준: {self.stop_loss_params["max_losing_positions"]}개)')
            self._execute_portfolio_sellout(current_prices, current_dt)
            return True
        return False

    def _execute_portfolio_sellout(self, current_prices: Dict[str, float], current_dt: datetime):
        """포트폴리오 전체 청산을 실행합니다."""
        logger.info(f"포트폴리오 전체 청산 실행: {current_dt.isoformat()}")
        stocks_to_sell = list(self.positions.keys() # 현재 보유 종목 리스트 복사
        for stock_code in stocks_to_sell:
            if stock_code in self.positions and self.positions[stock_code]['size'] > 0:
                quantity_to_sell = self.positions[stock_code]['size']
                current_price = current_prices.get(stock_code)
                if current_price:
                    self.execute_order(stock_code, 'sell', current_price, quantity_to_sell, current_dt, order_kind='03') # 시장가 매도
                else:
                    logger.error(f"청산 실패: {stock_code}의 현재가를 알 수 없어 매도할 수 없습니다.")
        logger.info("포트폴리오 전체 청산 주문 완료.")

    def reset_daily_transactions(self):
        """일일 거래 초기화를 수행합니다. (실전에서는 필요에 따라 구현)"""
        # 실전에서는 transaction_log를 매일 초기화할 필요는 없고, DB에 계속 쌓는 것이 일반적.
        # 여기서는 백테스팅과의 일관성을 위해 메서드만 유지.
        self.transaction_log = []
        logger.debug("일일 거래 로그 초기화 완료.")

Python

# trading/trading.py

import logging
import pandas as pd
from datetime import datetime, date, time, timedelta
import time as time_module # time 모듈과 충돌 방지
import sys
import os
from typing import Dict, Any

# sys.path에 프로젝트 루트 추가
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..')
sys.path.insert(0, project_root)

from trading.brokerage import Brokerage
from manager.trading_manager import TradeManager
from strategies.strategy import DailyStrategy, MinuteStrategy # 전략 추상 클래스 임포트
from util.strategies_util import get_next_weekday # 유틸리티 함수

logger = logging.getLogger(__name__)

class Trading:
    """
    실전 자동매매 시스템의 메인 실행 클래스.
    일일 및 분봉 전략을 실행하고, 브로커를 통해 실제 거래를 관리합니다.
    """
    def __init__(self, brokerage: Brokerage, trading_manager: TradeManager,
                 daily_strategy: DailyStrategy, minute_strategy: MinuteStrategy,
                 initial_cash: float):
        
        self.brokerage = brokerage
        self.trading_manager = trading_manager
        self.daily_strategy = daily_strategy
        self.minute_strategy = minute_strategy
        self.initial_cash = initial_cash # 초기 현금 (실제 계좌 현금과 동기화됨)

        self.trading_day_start_time = time(9, 0, 0)
        self.trading_day_end_time = time(15, 20, 0) # 장 마감 10분 전까지 거래
        self.minute_check_interval_seconds = 60 # 1분마다 체크 (실전에서는 API 호출 제한 고려)

        # 포트폴리오 가치 추적용
        self.portfolio_values = [] # (datetime, portfolio_value)
        self.last_portfolio_log_time = None

        logger.info("Trading 초기화 완료.")

    def start_trading_day(self, current_date: date):
        """
        거래일 시작 시 필요한 초기화 및 데이터 로드를 수행합니다.
        """
        logger.info(f"\n--- {current_date.isoformat()} 실전 자동매매 시작 ---")
        
        # 1. 증권사 계좌 정보 동기화
        if not self.brokerage.sync_account_info():
            logger.error("계좌 정보 동기화 실패. 거래를 시작할 수 없습니다.")
            sys.exit(1) # 동기화 실패 시 프로그램 종료 (재시도 로직 추가 가능)

        # 2. 초기 현금 및 포트폴리오 가치 설정 (API 조회 값으로)
        self.brokerage.initial_portfolio_value = self.brokerage.cash + self.brokerage.get_portfolio_value({}) # 초기 현금 + 현재 보유 주식 가치
        logger.info(f"시작 현금: {self.brokerage.cash:,.0f}원, 시작 포트폴리오 가치: {self.brokerage.initial_portfolio_value:,.0f}원")
        
        # 3. 거래 로그 초기화 (일일 기준)
        self.brokerage.reset_daily_transactions()

        # 4. 일봉 전략 실행 및 신호 생성/로드
        # 실전에서는 전날 데이터 기준으로 일봉 신호를 생성하거나, DB에서 로드
        prev_trading_day = self._get_previous_trading_day(current_date)
        if prev_trading_day:
            logger.info(f"전일({prev_trading_day.isoformat()}) 데이터 기반 일봉 전략 실행 및 신호 생성...")
            # 데이터 매니저를 통해 필요한 과거 데이터 로드
            # get_historical_ohlcv는 pandas DataFrame을 반환해야 함
            all_stock_codes = self.trading_manager.get_all_stock_codes() # 전체 종목 코드 가져오기

            # 일봉 전략을 위한 데이터 준비 (예: 200일치 일봉 데이터)
            daily_ohlcv_data = {}
            for code in all_stock_codes:
                df = self.trading_manager.get_historical_ohlcv(code, 'D', 200) # 200일치 일봉
                if df is not None and not df.empty:
                    daily_ohlcv_data[code] = df
            
            self.daily_strategy.data_store = daily_ohlcv_data # DataManager 대신 DataFrame 딕셔너리 직접 할당
            daily_signals = self.daily_strategy.generate_signals(prev_trading_day) # 전일 데이터 기준으로 신호 생성
            self.trading_manager.save_daily_signals(daily_signals, current_date) # 오늘 날짜로 신호 저장
            logger.info(f"일봉 전략 신호 {len(daily_signals)}개 생성 및 저장 완료.")
        else:
            logger.warning(f"{current_date.isoformat()}의 이전 거래일을 찾을 수 없습니다. 일봉 전략 신호 생성을 건너뜝니다.")
        
        # 5. 분봉 전략에 일봉 전략 신호 전달 (TradeManager를 통해 로드)
        signals_for_minute_strategy = self.trading_manager.load_daily_signals_for_today(current_date)
        self.minute_strategy.receive_daily_signals(signals_for_minute_strategy)
        logger.info(f"분봉 전략에 일봉 신호 {len(signals_for_minute_strategy)}개 전달 완료.")

        self.last_portfolio_log_time = datetime.now()
        self.portfolio_values.append((self.last_portfolio_log_time, self.brokerage.initial_portfolio_value)

    def _get_previous_trading_day(self, current_date: date) -> Optional[date]:
        """주어진 날짜의 이전 거래일을 DB에서 조회합니다."""
        # TODO: market_calendar 테이블에서 이전 거래일 조회 로직 구현 필요
        # 현재는 임시로 전날로 가정 (주말/공휴일 미고려)
        trading_calendar_df = self.trading_manager.db_manager.fetch_data("SELECT trading_date FROM market_calendar ORDER BY trading_date DESC")
        if not trading_calendar_df.empty:
            trading_dates = sorted([d.date() for d in trading_calendar_df['trading_date'].unique()])
            try:
                current_date_index = trading_dates.index(current_date)
                if current_date_index > 0:
                    return trading_dates[current_date_index - 1]
            except ValueError:
                logger.warning(f"거래일 캘린더에 {current_date.isoformat()}가 없습니다.")
        
        # Fallback for testing or if calendar is empty
        return current_date - timedelta(days=1)


    def run_trading_session(self, current_date: date):
        """
        실시간 거래 세션을 실행합니다.
        시장 개장 시간 동안 분봉 데이터를 처리하고 매매 로직을 수행합니다.
        """
        logger.info(f"--- {current_date.isoformat()} 실시간 거래 세션 시작 ---")
        
        while True:
            now = datetime.now()
            current_time = now.time()
            current_dt = now # datetime 객체로 통일

            # 장 시작 전 대기
            if current_time < self.trading_day_start_time:
                wait_seconds = (datetime.combine(current_date, self.trading_day_start_time) - now).total_seconds()
                if wait_seconds > 0:
                    logger.info(f"장 시작 전 대기 중... {int(wait_seconds)}초 남음")
                    time_module.sleep(min(wait_seconds, 60) # 최대 1분씩 대기
                continue

            # 장 마감 후 종료
            if current_time > self.trading_day_end_time:
                logger.info("거래 세션 종료 시간 도달. 실시간 거래를 종료합니다.")
                break

            # 매 분마다 처리 로직 실행
            if (now - self.last_portfolio_log_time).total_seconds() >= self.minute_check_interval_seconds:
                self.last_portfolio_log_time = now
                logger.info(f"현재 시각: {current_dt.strftime('%H:%M:%S')} - 분봉 전략 및 손절매 조건 확인 시작")

                # 1. 현재 보유 종목의 실시간 현재가 조회
                current_prices = {}
                for stock_code in self.brokerage.positions.keys():
                    price = self.trading_manager.get_realtime_price(stock_code)
                    if price:
                        current_prices[stock_code] = price
                
                # 2. 포트폴리오 손절매 체크 (개별 종목 손절보다 먼저 확인)
                if self.brokerage.check_and_execute_portfolio_stop_loss(current_prices, current_dt):
                    logger.warning("포트폴리오 전체 손절매 조건 충족. 거래 세션을 종료합니다.")
                    break # 전체 손절 시 세션 종료

                # 3. 각 보유 종목 및 신호 종목에 대한 분봉 전략 및 개별 손절매 실행
                stocks_to_check = set(self.brokerage.positions.keys() # 현재 보유 종목
                # 오늘 일봉 전략에서 받은 신호 종목 (매수 후보)도 포함하여 실시간 데이터 조회
                signals_for_minute_strategy = self.trading_manager.load_daily_signals_for_today(current_date)
                stocks_to_check.update(signals_for_minute_strategy.keys()
                
                for stock_code in stocks_to_check:
                    # 개별 종목 손절매 체크 (보유 종목에 대해서만)
                    if stock_code in self.brokerage.positions:
                        price_for_stop_loss = current_prices.get(stock_code)
                        if price_for_stop_loss and self.brokerage.check_and_execute_stop_loss(stock_code, price_for_stop_loss, current_dt):
                            logger.info(f"{stock_code} 개별 손절매 실행 완료.")
                            continue # 손절매 실행 시 해당 종목은 더 이상 분봉 전략 처리 불필요

                    # 분봉 전략 실행
                    minute_data_df = self.trading_manager.get_realtime_minute_data(stock_code)
                    if minute_data_df is not None and not minute_data_df.empty:
                        # 분봉 전략의 data_store를 현재 분봉 데이터로 설정
                        self.minute_strategy.data_store = {stock_code: minute_data_df}
                        self.minute_strategy.process_minute_data(stock_code, current_dt)
                    else:
                        logger.warning(f"{stock_code}의 실시간 분봉 데이터를 가져올 수 없습니다. 분봉 전략 건너뜀.")
                
                # 4. 현재 포트폴리오 가치 기록
                current_portfolio_value = self.brokerage.get_portfolio_value(current_prices)
                self.portfolio_values.append((current_dt, current_portfolio_value)
                logger.info(f"현재 포트폴리오 가치: {current_portfolio_value:,.0f}원")

            time_module.sleep(self.minute_check_interval_seconds) # 다음 분봉 처리까지 대기

        logger.info(f"--- {current_date.isoformat()} 실시간 거래 세션 종료 ---")


    def end_trading_day(self, end_date: date):
        """
        거래일 종료 시 필요한 마무리 작업을 수행합니다.
        """
        logger.info(f"\n--- {end_date.isoformat()} 실전 자동매매 종료 ---")

        # 1. 최종 포트폴리오 스냅샷 저장
        # 마지막 포트폴리오 가치 기록 시점의 정보를 사용
        final_current_prices = {}
        for stock_code in self.brokerage.positions.keys():
            price = self.trading_manager.get_realtime_price(stock_code)
            if price:
                final_current_prices[stock_code] = price

        final_portfolio_value = self.brokerage.get_portfolio_value(final_current_prices)
        self.trading_manager.save_daily_portfolio_snapshot(
            snapshot_date=end_date,
            portfolio_value=final_portfolio_value,
            cash=self.brokerage.cash,
            positions=self.brokerage.positions
        )
        logger.info(f"최종 포트폴리오 스냅샷 저장 완료: {end_date}, 가치: {final_portfolio_value:,.0f}원")

        # 2. DB 연결 종료
        self.trading_manager.close()
        logger.info("Trading 작업 완료. DB 연결 종료.")

    # Reporter 관련 기능은 백테스팅에서 주로 사용하며, 실전에서는 TradeManager를 통해 DB에 기록
    # 필요하다면 Reporter와 유사한 보고서 생성 기능을 TradeManager에 추가하거나 별도 모듈로 분


A :
    Trading, Brokerage, 및 파일 TradeManager이 라이브 트레이딩을 위한 Creon API 클라이언트와 함께 성공적으로 생성되었습니다( creon_api_live.py).

    생성된 파일을 요약한 내용과 해당 파일이 귀하의 요구 사항을 충족하는 방식은 다음과 같습니다.

    생성된 파일
    api/creon_api_live.py:
        이 파일은 백테스팅에 사용되는 것과 유사하게 실시간 거래를 위한 Creon Plus API와 상호작용하기 위한 통합 인터페이스를 제공합니다 creon_api.py.
        메서드 명명 및 데이터 유형 : get_market_calendar, get_price_data, get_latest_financial_data, get_all_stock_codes, get_current_price, send_order, get_account_balance, 및 와 같은 메서드는 get_portfolio_positions명명, 인수 및 반환 유형(예: 숫자 값의 경우)에서 일관성을 유지하도록 설계 datetime.date되었습니다 float.
        실시간 데이터, 주문, 계정 조회에 필요한 COM 객체 상호작용을 캡슐화합니다.

    manager/trading_manager.py:
        이 클래스는 실시간 거래에 필수적인 데이터의 관리와 지속성을 다룹니다.
        기능 :
        save_daily_signals, load_daily_signals_for_today: 데이터베이스에서 일일 전략 신호를 관리합니다.
        save_trading_log: 실행된 모든 거래를 기록합니다.
        save_daily_portfolio_snapshot, load_last_portfolio_snapshot: 시간 경과에 따른 포트폴리오 가치와 구성을 추적합니다.
        save_current_positions, load_current_positions: 현재 재고 보유량을 유지하고 로드합니다.
        get_realtime_price, get_realtime_minute_data, get_historical_ohlcv, get_all_stock_codes: 증권사 API(creon_api.py)다양한 유형의 시장 데이터를 가져오기 위한 인터페이스입니다.
        update_market_calendar, update_stock_info: 데이터베이스에서 시장 일정과 주식 기본 정보를 최신 상태로 유지합니다.

    trading/brokerage.py:
        이 클래스는 AbstractBroker실시간 거래를 구현하여 Creon API를 통해 실제 거래 실행을 가능하게 합니다.
        기능 :
        __init__: 종속성을 사용하여 초기화 증권사 API(creon_api.py)합니다 TradeManager.
        sync_account_info: 브로커의 현금 및 포지션 데이터를 귀하의 실제 Creon 계정과 주기적으로 동기화합니다.
        execute_order: 실제 매수/매도 주문을 전송하고 증권사 API(creon_api.py).send_order거래 로그에 기록합니다. 또한 시뮬레이션된 실행 결과를 기반으로 내부 현금 및 포지션을 업데이트합니다. (실제 실행 상태는 실시간 콜백 또는 폴링이 필요합니다.)
        get_position_size, get_portfolio_value: 현재 보유 정보를 검색하고 포트폴리오 가치를 계산합니다.
        set_stop_loss_params, check_and_execute_stop_loss, check_and_execute_portfolio_stop_loss: 조건이 충족되면 실제 매도 주문을 실행하여 손절매 및 포트폴리오 손절매 논리를 구현합니다.
    
    trading/trading.py:
        이는 자동 거래 시스템의 주요 오케스트레이터입니다.
        기능 :
        __init__Brokerage: , TradeManager, 및 일일/분 전략을 설정합니다 .

            start_trading_day: 거래일 시작 시 시스템을 준비합니다. 여기에는 계정 정보 동기화, 일일 신호 로드/생성, 이를 분 단위 전략으로 전달하는 작업이 포함됩니다.

            run_trading_session: 시장 시간 동안 작동하는 메인 루프를 포함합니다. 실시간 분 단위 데이터를 가져오고, 손절매 조건을 확인하고, 분 단위 거래 전략을 실행합니다.

            end_trading_day: 최종 포트폴리오 스냅샷을 저장하는 등 하루가 끝나면 정리 작업을 수행합니다.
            중요 참고 사항:

    Creon.py통합 : 
        수정된 Creon API 클라이언트가 포함된 새 파일을 생성했습니다 api/creon_api_live.py. 이 파일의 내용을 사용하여 기존 파일을 대체하거나 통합하거나 Creon.py, 라이브 API 클라이언트로 올바르게 참조되도록 해야 합니다.
        실시간 데이터 : 증권사 API(creon_api.py)"요청-응답" 기반 실시간 가격 및 분 단위 데이터를 제공합니다. 진정으로 연속적이고 빈도가 높은 실시간 스트리밍을 위해 Creon의 COM API는 일반적으로 이벤트 핸들러 설정을 포함하는데, 이는 여기에서 완전히 구현되지 않은 고급 주제입니다. 현재 설정은 1분마다 데이터를 폴링합니다.
    
    데이터베이스 스키마 : 
        TradeManager 는 daily_signals, transaction_log, daily_portfolio_snapshot, current_positions, market_calendar, stock_info, create_stock_tables.sql 와 같은 데이터베이스 테이블이 존재한다고 가정합니다 . 데이터베이스 스키마(예: )가 이러한 테이블을 지원하는지 확인하세요. 
    
    거래 확인 : 
        Brokerage.execute_order현재 API 요청이 성공하는 즉시 주문이 기록됩니다. 안정적인 라이브 시스템에서는 일반적으로 실시간 콜백 또는 정기적인 주문 상태 확인을 통해 실제 거래 확인이 이루어질 때까지 기다렸다가 포지션을 업데이트하고 정확하게 현금화합니다.
    
    이 파일들은 실시간 자동 거래 시스템을 위한 탄탄한 기반을 제공합니다. 추가 문의 사항이나 수정 사항이 있으시면 언제든지 알려주세요!

    필요한 경우 언제든지 문의하세요.

    이러한 파일을 더욱 세부적으로 조정합니다.
    특정 실시간 데이터 처리(예: 이벤트 기반)를 구현합니다.
    더욱 자세한 오류 처리나 재시도 메커니즘을 추가합니다.
    기존 코드의 다른 부분과 통합합니다.


데이터 메니저 VS 트레이드 메니저
1. data_manager.py의 역할
    핵심 역할
    데이터 통합 관리 계층
    DB와 외부 API(예: 증권사 API(creon_api.py) 양쪽을 모두 다루며,
    “데이터를 어디서 어떻게 가져올지, 어떻게 캐싱/동기화할지”를 책임지는 중간 관리자 역할
    주요 기능
    DBManager, 증권사 API(creon_api.py) 인스턴스 생성 및 관리
    DB와 API를 조합한 데이터 캐싱/동기화
    예: 일봉/분봉 데이터가 DB에 없으면 API에서 가져와 DB에 저장 후 반환
    시장 캘린더, 종목 정보 등 초기 데이터 세팅/업데이트
    데이터 가공/전처리
    예: DB와 API 데이터를 합쳐서 최종 DataFrame 반환
    DB 연결 관리
    DB 연결 종료(close) 등
    비즈니스 로직
    거의 없음.
    데이터의 “저장 위치/출처”를 추상화하고,
    필요한 데이터를 “최적의 경로(DB→API)”로 가져오는 것이 주 목적.

2. trading_manager.py의 역할 (이전 구조 기준, 현재는 분리/통합됨)
    핵심 역할
    트레이딩/백테스트 비즈니스 로직 계층
    “전략 실행, 신호 생성, 거래 기록, 포트폴리오 관리” 등
    실제 트레이딩/백테스트의 핵심 로직을 담당
    주요 기능
    트레이딩 신호 저장/조회
    save_daily_signals, load_daily_signals_for_today 등
    거래 로그, 포트폴리오 스냅샷, 보유 종목 관리
    save_trading_log, save_daily_portfolio_snapshot, save_current_positions 등
    실시간/과거 데이터 조회 및 가공
    get_realtime_price, get_historical_ohlcv 등 (현재는 backtest_manager.py로 이동)
    종목/캘린더/재무정보 업데이트
    update_market_calendar, update_stock_info 등 (현재는 backtest_manager.py로 이동)
    전략별 지표 계산, 성과 집계 등 (일부는 backtest_manager.py, 일부는 전략 util로 분리)
    비즈니스 로직
    매우 많음.
    “언제 어떤 신호를 저장/조회할지, 거래 기록을 어떻게 남길지, 포트폴리오 상태를 어떻게 관리할지” 등
    실제 트레이딩/백테스트의 흐름과 규칙을 구현
